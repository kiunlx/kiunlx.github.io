<!DOCTYPE HTML>
<html lang="">
<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="Hexo">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://yoursite.com">
    <!--SEO-->





<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->


<title>java基础 | Hexo</title>


    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    

</head>


<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)"  >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='kiunlx'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                 <img src="/img/branding.png" alt="Snippet 博客主题" class="img-responsive center-block">
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://yoursite.com">Hexo</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>Home</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/前端/"><i class="fa "></i>前端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/后端/"><i class="fa "></i>后端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/工具/"><i class="fa "></i>工具</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>时间轴</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="java基础">
            
	            java基础
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a href="/categories/后端">
            后端
        </a>
    </span>
    

    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
                
                    <a href="/tags/java" title='java'>
                        java
                    </a>
                
                    <a href="/tags/后端" title='后端'>
                        后端
                    </a>
                
            
        </span>
    </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2019/04/22</span>
        </span>
        
    
</div>

            
            
    </div>
    
    <div class="post-body post-content">
        <p>[Toc]</p>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="1-双引号直接创建字符串和new创建字符串有什么区别"><a href="#1-双引号直接创建字符串和new创建字符串有什么区别" class="headerlink" title="1.双引号直接创建字符串和new创建字符串有什么区别"></a>1.双引号直接创建字符串和new创建字符串有什么区别</h2><p>  new创建字符串，会在堆内存中直接创建一个。如果常量池中没有，则还会在常量池中再创建一个。</p>
<h2 id="2-API接口和SDI接口的区别"><a href="#2-API接口和SDI接口的区别" class="headerlink" title="2.API接口和SDI接口的区别"></a>2.API接口和SDI接口的区别</h2><p>  SDI是硬件接口，不如显示器的HDMI，DVI接口之类，java一般都是Restful和SDK接口</p>
<h2 id="3-强引用，软引用，弱引用，虚引用"><a href="#3-强引用，软引用，弱引用，虚引用" class="headerlink" title="3.强引用，软引用，弱引用，虚引用"></a>3.强引用，软引用，弱引用，虚引用</h2><p> 强引用:<br><br> 只要引用存在，垃圾回收器永远不会回收<br><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();&lt;/br&gt;</span><br></pre></td></tr></table></figure></p>
<p> 可直接通过obj取得对应的对象 如obj.equels(new Object());<br><br> 而这样obj对象对后面new Object的一个强引用,只有当obj这个引用被释放之后，对象才会被释放掉，这也是我们经常所用到的编码形式。<br> <br><br><br> 软引用:<br>非必须引用，内存溢出之前进行回收，可以通过以下代码实现<br><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();  &lt;/br&gt;</span><br><span class="line">SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);&lt;/br&gt;</span><br><span class="line">obj = null;&lt;/br&gt;</span><br><span class="line">sf.get();//有时候会返回null&lt;/br&gt;</span><br></pre></td></tr></table></figure></p>
<p> 这时候sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回null；<br> 软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。<br> <br><br><br> 弱引用:  <br><br> 第二次垃圾回收时回收，可以通过如下代码实现  <br><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();  &lt;/br&gt;</span><br><span class="line">WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);  &lt;/br&gt;</span><br><span class="line">obj = null;  &lt;/br&gt;</span><br><span class="line">wf.get();//有时候会返回null  &lt;/br&gt;</span><br><span class="line">wf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾  &lt;/br&gt;</span><br></pre></td></tr></table></figure></p>
<p> 弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。<br><br> 弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记。<br><br><br> 虚引用:<br><br> 垃圾回收时回收，无法通过引用取到对象值，可以通过如下代码实现<br><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();&lt;/br&gt;</span><br><span class="line">PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj);&lt;/br&gt;</span><br><span class="line">obj=null;&lt;/br&gt;</span><br><span class="line">pf.get();//永远返回null&lt;/br&gt;</span><br><span class="line">pf.isEnQueued();//返回是否从内存中已经删除&lt;/br&gt;</span><br></pre></td></tr></table></figure></p>
<p> 虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用。<br><br> 虚引用主要用于检测对象是否已经从内存中删除。<br><br><br> 引用网址:<a href="https://www.cnblogs.com/yw-ah/p/5830458.html" target="_blank" rel="noopener">https://www.cnblogs.com/yw-ah/p/5830458.html</a></p>
<h2 id="4-为什么Java不是100-面向对象"><a href="#4-为什么Java不是100-面向对象" class="headerlink" title="4.为什么Java不是100%面向对象"></a>4.为什么Java不是100%面向对象</h2><p> <font color="#000" size="3" face="黑体">因为还有8个基本类型</font></p>
<h2 id="5-自动拆箱装箱的原理"><a href="#5-自动拆箱装箱的原理" class="headerlink" title="5.自动拆箱装箱的原理"></a>5.自动拆箱装箱的原理</h2><p> 概念：<br><br> 自动装箱：Java自动将原始类型值转换成对应的对象，比如将int的变量转换成Integer对象，这个过程叫做装箱。<br><br><br> 自动拆箱：反之将Integer对象转换成int类型值，这个过程叫做拆箱。因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。<br><br><br> 原理：</p>
<p> 1）自动装箱时编译器调用valueOf将原始类型值转换成对象。</p>
<p> 2）同时自动拆箱时，编译器通过调用类似intValue(),doubleValue()这类的方法将对象转换成原始类型值。<br><br><br> Integer缓存：<br><br> 在 Java 5 中，为 Integer 的操作引入了一个新的特性，用来节省内存和提高性能。整型对象在内部实现中通过使用相同的对象引用实现了缓存和重用。<br><br><br> 上面的规则适用于整数区间 -128 到 +127。<br> 这种 Integer 缓存策略仅在自动装箱（autoboxing）的时候有用，使用构造器创建的 Integer 对象不能被缓存。</p>
<p> Java 编译器把原始类型自动转换为封装类的过程称为自动装箱（autoboxing），这相当于调用 valueOf 方法.</p>
<p> 在创建新的 Integer 对象之前会先在 IntegerCache.cache 中查找。有一个专门的 Java 类来负责 Integer 的缓存。</p>
<p> IntegerCache类是用来实现缓存支持，并支持 -128 到 127 之间的自动装箱过程。最大值 127 可以通过 JVM 的启动参数 -XX:AutoBoxCacheMax=size 修改。 缓存通过一个 for 循环实现。从小到大的创建尽可能多的整数并存储在一个名为 cache 的整数数组中。这个缓存会在 Integer 类第一次被使用的时候被初始化出来。以后，就可以使用缓存中包含的实例对象，而不是创建一个新的实例(在自动装箱的情况下)。</p>
<p> 实际上在 Java 5 中引入这个特性的时候，范围是固定的 -128 至 +127。后来在 Java 6 中，最大值映射到 java.lang.Integer.IntegerCache.high，可以使用 JVM 的启动参数设置最大值。这使我们可以根据应用程序的实际情况灵活地调整来提高性能。是什么原因选择这个 -128 到 127 这个范围呢？因为这个范围的整数值是使用最广泛的。 在程序中第一次使用 Integer 的时候也需要一定的额外时间来初始化这个缓存。</p>
<p> 这种缓存行为不仅适用于Integer对象。我们针对所有整数类型的类都有类似的缓存机制。</p>
<p> 有 ByteCache 用于缓存 Byte 对象</p>
<p> 有 ShortCache 用于缓存 Short 对象</p>
<p> 有 LongCache 用于缓存 Long 对象</p>
<p> 有 CharacterCache 用于缓存 Character 对象</p>
<p> Byte，Short，Long 有固定范围: -128 到 127。对于 Character, 范围是 0 到 127。除了 Integer 可以通过参数改变范围外，其它的都不行。</p>
<h2 id="6-cloneable接口实现原理，浅拷贝和深拷贝"><a href="#6-cloneable接口实现原理，浅拷贝和深拷贝" class="headerlink" title="6.cloneable接口实现原理，浅拷贝和深拷贝"></a>6.cloneable接口实现原理，浅拷贝和深拷贝</h2><p> ps：深拷贝难以完全形成深拷贝，因为这要求继承链上的所有对象都集成Cloneable接口，实现clone方法，来保证非基本类型的对象被深拷贝。<br><br> Java中对象的创建:<br><br> clone顾名思义就是复制， 在Java语言中， clone方法被对象调用，所以会复制对象。所谓的复制对象，首先要分配一个和源对象同样大小的空间，在这个空间中创建一个新的对象。那么在java语言中，有几种方式可以创建对象呢？<br><br><br> 1 使用new操作符创建一个对象。<br><br><br> 2 使用clone方法复制一个对象。<br><br><br> 那么这两种方式有什么相同和不同呢？ new操作符的本意是分配内存。程序执行到new操作符时， 首先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。而clone在第一步是和new相似的， 都是分配内存，调用clone方法时，分配的内存和源对象（即调用clone方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域， 填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。<br><br><br> 现在为了要在clone对象时进行深拷贝， 那么就要Clonable接口，覆盖并实现clone方法，除了调用父类中的clone方法得到新的对象， 还要将该类中的引用变量也clone出来。如果只是用Object中默认的clone方法，是浅拷贝的。<br><br><br> 如果想要深拷贝一个对象， 这个对象必须要实现Cloneable接口，实现clone方法，并且在clone方法内部，把该对象引用的其他对象也要clone一份 ， 这就要求这个被引用的对象必须也要实现Cloneable接口并且实现clone方法。<br><br><br> 引用：<a href="https://blog.csdn.net/cws1214/article/details/52193341" target="_blank" rel="noopener">https://blog.csdn.net/cws1214/article/details/52193341</a></p>
<h2 id="7-Java中TreeMap实现原理"><a href="#7-Java中TreeMap实现原理" class="headerlink" title="7.Java中TreeMap实现原理"></a>7.Java中TreeMap实现原理</h2><p> 使用了红黑树实现的<br><br><br> 引用：<a href="https://blog.csdn.net/cyywxy/article/details/81151104" target="_blank" rel="noopener">https://blog.csdn.net/cyywxy/article/details/81151104</a></p>
<h2 id="8-fail-fast和fail-safe"><a href="#8-fail-fast和fail-safe" class="headerlink" title="8.fail-fast和fail-safe"></a>8.fail-fast和fail-safe</h2><p> 快速失败（fail-fast）</p>
<p> 在使用迭代器对集合对象进行遍历的时候，如果 A 线程正在对集合进行遍历，此时 B 线程对集合进行修改（增加、删除、修改），或者 A 线程在遍历过程中对集合进行修改，都会导致 A 线程抛出 ConcurrentModificationException 异常。</p>
<p> 安全失败（fail-safe）</p>
<p> 明白了什么是快速失败之后，安全失败也是非常好理解的。</p>
<p> 采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p>
<p> 由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛 ConcurrentModificationException 异常</p>
<p> 引用：<a href="https://blog.51cto.com/13732225/2316412" target="_blank" rel="noopener">https://blog.51cto.com/13732225/2316412</a></p>
<h2 id="10-ArrayList，LinkedList差异，应用场景"><a href="#10-ArrayList，LinkedList差异，应用场景" class="headerlink" title="10.ArrayList，LinkedList差异，应用场景"></a>10.ArrayList，LinkedList差异，应用场景</h2><ol>
<li><p>LinkedList和ArrayList的差别主要来自于Array和LinkedList数据结构的不同。ArrayList是基于数组实现的，LinkedList是基于双链表实现的。另外LinkedList类不仅是List接口的实现类，可以根据索引来随机访问集合中的元素，除此之外，LinkedList还实现了Deque接口，Deque接口是Queue接口的子接口，它代表一个双向队列，因此LinkedList可以作为双向对列，栈（可以参见Deque提供的接口方法）和List集合使用，功能强大。</p>
</li>
<li><p>因为Array是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的，可以直接返回数组中index位置的元素，因此在随机访问集合元素上有较好的性能。Array获取数据的时间复杂度是O(1),但是要插入、删除数据却是开销很大的，因为这需要移动数组中插入位置之后的的所有元素。</p>
</li>
<li><p>相对于ArrayList，LinkedList的随机访问集合元素时性能较差，因为需要在双向列表中找到要index的位置，再返回；但在插入，删除操作是更快的。因为LinkedList不像ArrayList一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是ArrayList最坏的一种情况，时间复杂度是O(n)，而LinkedList中插入或删除的时间复杂度仅为O(1)。ArrayList在插入数据时还需要更新索引（除了插入数组的尾部）。</p>
</li>
<li><p>LinkedList需要更多的内存，因为ArrayList的每个索引的位置是实际的数据，而LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。</p>
<p>使用场景：</p>
<p> （1）如果应用程序对对数据有较多的随机访问，ArrayList对象要优于LinkedList对象；</p>
<p>  (2) 如果应用程序有更多的插入或者删除操作，较少的数据读取，LinkedList对象要优于ArrayList对象；</p>
<p> （3）不过ArrayList的插入，删除操作也不一定比LinkedList慢，如果在List靠近末尾的地方插入，那么ArrayList只需要移动较少的数据，而LinkedList则需要一直查找到列表尾部，反而耗费较多时间，这时ArrayList就比LinkedList要快。</p>
<p>原文：<a href="https://blog.csdn.net/u012216131/article/details/82500925" target="_blank" rel="noopener">https://blog.csdn.net/u012216131/article/details/82500925</a> </p>
</li>
</ol>
<h2 id="11-HashMap碰撞扩容原理，在JDK1-8有哪些改"><a href="#11-HashMap碰撞扩容原理，在JDK1-8有哪些改" class="headerlink" title="11.HashMap碰撞扩容原理，在JDK1.8有哪些改"></a>11.HashMap碰撞扩容原理，在JDK1.8有哪些改</h2><p>Hashmap的扩容需要满足两个条件：当前数据存储的数量（即size()）大小必须大于等于阈值；当前加入的数据是否发生了hash冲突。</p>
<p>因为上面这两个条件，所以存在下面这些情况</p>
<p>（1）、就是hashmap在存值的时候（默认大小为16，负载因子0.75，阈值12），可能达到最后存满16个值的时候，再存入第17个值才会发生扩容现象，因为前16个值，每个值在底层数组中分别占据一个位置，并没有发生hash碰撞。</p>
<p>（2）、当然也有可能存储更多值（超多16个值，最多可以存26个值）都还没有扩容。原理：前11个值全部hash碰撞，存到数组的同一个位置（这时元素个数小于阈值12，不会扩容），后面所有存入的15个值全部分散到数组剩下的15个位置（这时元素个数大于等于阈值，但是每次存入的元素并没有发生hash碰撞，所以不会扩容），前面11+15=26，所以在存入第27个值的时候才同时满足上面两个条件，这时候才会发生扩容现象。</p>
<h2 id="12-ConcurrentHashMap和HashMap区别在哪"><a href="#12-ConcurrentHashMap和HashMap区别在哪" class="headerlink" title="12.ConcurrentHashMap和HashMap区别在哪"></a>12.ConcurrentHashMap和HashMap区别在哪</h2><p> ConcurrentHashMap是线程安全，HashMap线程不安全。ConcurrentHashMap是线程安全在JDK7中是基于分段锁。JDK8基于CAS远离。</p>
<h2 id="13-HashMap什么时候使用红黑树"><a href="#13-HashMap什么时候使用红黑树" class="headerlink" title="13.HashMap什么时候使用红黑树"></a>13.HashMap什么时候使用红黑树</h2><p> 链表长度大于8的时候</p>
<h2 id="14-序列化接口的id什么作用"><a href="#14-序列化接口的id什么作用" class="headerlink" title="14.序列化接口的id什么作用"></a>14.序列化接口的id什么作用</h2><p> 反序列的时候能找到对应的类</p>

    </div>
    
        <div class="reward">
    <div class="reward-wrap">赏
        <div class="reward-box">
            
            
                <span class="reward-type">
                    <img class="wechat" src="../img/reward-wepay.jpg"><b>微信打赏</b>
                </span>
            
        </div>
    </div>
    <p class="reward-tip">赞赏是不耍流氓的鼓励</p>
</div>


    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">Snippet</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
    
        <a href="/2018/12/04/centos内核调优/" class="next-post btn btn-default" title='centos内核调优'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">centos内核调优</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
    
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: 'xOKV9J4UeQAtVkvnJC7Kq2Jn-gzGzoHsz',
            appKey: 'erIpQac4azoCmgfBB7Dl9maa',
            placeholder: '说点什么吧',
            notify: false,
            verify: false,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: ''.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">Table of Contents</h3>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java"><span class="toc-text">Java</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-双引号直接创建字符串和new创建字符串有什么区别"><span class="toc-text">1.双引号直接创建字符串和new创建字符串有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-API接口和SDI接口的区别"><span class="toc-text">2.API接口和SDI接口的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-强引用，软引用，弱引用，虚引用"><span class="toc-text">3.强引用，软引用，弱引用，虚引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-为什么Java不是100-面向对象"><span class="toc-text">4.为什么Java不是100%面向对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-自动拆箱装箱的原理"><span class="toc-text">5.自动拆箱装箱的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-cloneable接口实现原理，浅拷贝和深拷贝"><span class="toc-text">6.cloneable接口实现原理，浅拷贝和深拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Java中TreeMap实现原理"><span class="toc-text">7.Java中TreeMap实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-fail-fast和fail-safe"><span class="toc-text">8.fail-fast和fail-safe</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-ArrayList，LinkedList差异，应用场景"><span class="toc-text">10.ArrayList，LinkedList差异，应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-HashMap碰撞扩容原理，在JDK1-8有哪些改"><span class="toc-text">11.HashMap碰撞扩容原理，在JDK1.8有哪些改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-ConcurrentHashMap和HashMap区别在哪"><span class="toc-text">12.ConcurrentHashMap和HashMap区别在哪</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-HashMap什么时候使用红黑树"><span class="toc-text">13.HashMap什么时候使用红黑树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-序列化接口的id什么作用"><span class="toc-text">14.序列化接口的id什么作用</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2017
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>